<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <title>实现ArcGIS JS API在地图上绘制虚线箭头</title>
    <style>
      html,
      body,
      #viewDiv {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
      }
    </style>

    <link
      rel="stylesheet"
      href="https://js.arcgis.com/4.16/esri/css/main.css"
    />
    <script src="https://js.arcgis.com/4.16/"></script>

    <script type="module">
      import * as THREE from '../libs/threejs/three.module.r119.js';
      import {
        CSS2DRenderer,
        CSS2DObject,
      } from '../libs/threejs/CSS2DRenderer.js';

      require([
        'esri/Map',
        'esri/views/SceneView',
        'esri/Graphic',
        'esri/geometry/Polyline',
        'esri/layers/GraphicsLayer',
        'esri/geometry/geometryEngine',
        'esri/geometry/Point',
      ], function (
        Map,
        SceneView,
        Graphic,
        Polyline,
        GraphicsLayer,
        geometryEngine,
        Point
      ) {
        const lineSymbol = {
          type: 'simple-line',
          width: '8px',
          color: '#ff0000',
        };
        const pointSymbol = {
          type: 'simple-marker',
          color: '#ffffff',
          size: '8px',
          outline: {
            color: '#000000',
            width: 1,
          },
        };
        const map = new Map({
          basemap: 'topo-vector',
        });

        const view = new SceneView({
          container: 'viewDiv',
          map: map,
          camera: {
            position: [104.06340647710485, 30.659828202233566, 1000],
            tilt: 0,
          },
        });
        let clickHandler; // 点击事件
        let doubleClickHandler; // 双击事件
        let pathPoints = []; // 画线过程中点击的点列表
        let linesPath = []; // 画好的线路经
        let tempLayer = createLayer({ id: 'tempLayer', title: '临时图层' }); // 创建临时图层
        let lineLayer = createLayer({ id: 'lineLayer', title: '虚线箭头图层' });

        map.add(tempLayer);
        map.add(lineLayer);

        let extentOnChange = throttle(() => {
          updateLine();
          updateGraphics();
        }, 300);
        createClickHandler();
        view.watch('extent', () => {
          extentOnChange();
        });

        // 函数截流
        function throttle(fn, delay) {
          let pre = Date.now();
          return function () {
            const context = this;
            const args = arguments;
            const now = Date.now();
            if (now - pre >= delay) {
              fn.apply(context, args);
              pre = Date.now();
            }
          };
        }

        // 绑定点击事件
        function createClickHandler() {
          removeClickHandler(); // 清除点击事件
          view.container.style.cursor = 'crosshair';
          clickHandler = view.on('click', (event) => {
            console.log(event);
            pathPoints.push(event.mapPoint);
            updateGraphics(); // 更新图形
          });
          // 双击结束
          doubleClickHandler = view.on('double-click', (event) => {
            if (pathPoints.length > 0) {
              event.stopPropagation();
              removeClickHandler();
              pathPoints.push(event.mapPoint);
              linesPath.push({
                lineStyle: document.getElementById('form').lineStyle.value,
                points: pathPoints,
              });
              updateLine();
              pathPoints = [];
              tempLayer.removeAll();
              createClickHandler();
            }
          });
        }

        // 清除点击事件
        function removeClickHandler() {
          view.container.style.cursor = 'default';
          if (clickHandler) {
            clickHandler.remove();
            clickHandler = null;
          }
          if (doubleClickHandler) {
            doubleClickHandler.remove();
            doubleClickHandler = null;
          }
        }

        // 生成图层
        function createLayer(options) {
          let layer = new GraphicsLayer(options);
          return layer;
        }

        // 更新
        function updateGraphics() {
          tempLayer.removeAll(); // 清除全部
          let pointGraphics = []; // 小圆点列表
          for (let i = 0; i < pathPoints.length; i++) {
            pointGraphics.push(
              new Graphic({
                geometry: pathPoints[i],
                symbol: pointSymbol,
              })
            );
          }
          tempLayer.addMany(pointGraphics);

          let paths = [];
          // 判断线类型
          let lineStyle = document.getElementById('form').lineStyle.value;
          if (lineStyle === 'straight') {
            // 直线
            let fullLine = createLineByPoints(pathPoints);
            let cliped = geometryEngine.clip(fullLine, view.extent); // 裁剪后的
            if (cliped && cliped.paths.length && cliped.paths[0].length) {
              for (let i = 0; i < cliped.paths.length; i++) {
                let arr = [];
                for (let j = 1; j < cliped.paths[i].length; j++) {
                  let dottedPaths = getSegmentDottedPaths(
                    cliped.paths[i][j - 1],
                    cliped.paths[i][j]
                  );
                  arr.push(...dottedPaths);
                }
                paths.push(...arr);
              }
            }
          } else if (lineStyle === 'curve') {
            // 曲线
            let points = pathPoints.map((item) => [item.x, item.y]);
            paths = getCurvePaths(points);
          }
          let line = new Polyline({
            paths: paths,
            spatialReference: view.spatialReference,
          });
          let graphic = new Graphic({
            geometry: line,
            symbol: lineSymbol,
          });
          tempLayer.add(graphic);
        }

        // 获取曲线paths
        function getCurvePaths(points) {
          let paths = [];
          if (points.length === 2) {
            // 只有两个点时画直线
            let dottedPaths = getSegmentDottedPaths(
              [points[0][0], points[0][1]],
              [points[1][0], points[1][1]]
            );
            paths.push(...dottedPaths);
          } else if (points.length > 2) {
            // 大于两个点时画贝塞尔曲线
            let controlPoints = getBezierControlPoints(points); // 控制点
            let bezierPoints = [];
            for (let i = 0; i < points.length - 1; i++) {
              let list = getBezierPoints(
                100,
                points[i],
                controlPoints[i * 2],
                controlPoints[i * 2 + 1],
                points[i + 1]
              );
              bezierPoints = bezierPoints.concat(list);
            }
            let fullLine = new Polyline({
              paths: [bezierPoints],
              spatialReference: view.spatialReference,
            });
            let resolution = view.resolution;
            let distance = 20 * resolution;
            let cliped = geometryEngine.clip(fullLine, view.extent); // 裁剪后的
            if (cliped && cliped.paths.length && cliped.paths[0].length) {
              for (let i = 0; i < cliped.paths.length; i++) {
                let path = [];
                let len = 0; // 长度
                let isSpace = false; // 是否是间隔段
                for (let j = 1; j < cliped.paths[i].length; j++) {
                  let p1 = cliped.paths[i][j - 1];
                  let p2 = cliped.paths[i][j];
                  let loop = true; // 是否循环
                  while (loop) {
                    if (len === 0) {
                      path.push(p1);
                    }
                    // 两点距离
                    let dis = Math.sqrt(
                      Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2)
                    );
                    if (len + dis > distance) {
                      // 长度大于虚线线段长度，则需要加点分割
                      let delta = distance - len; //
                      let ratio = delta / dis;
                      let p_x = p1[0] + (p2[0] - p1[0]) * ratio; // 分割点x坐标
                      let p_y = p1[1] + (p2[1] - p1[1]) * ratio; // 分割点y坐标
                      path.push([p_x, p_y]);
                      if (!isSpace) {
                        paths.push(path);
                      }
                      isSpace = !isSpace;
                      len = 0;
                      path = [];
                      p1 = [p_x, p_y];
                    } else if (len + dis < distance) {
                      path.push(p2);
                      len += dis;
                      loop = false;
                    } else {
                      path.push(p2);
                      if (!isSpace) {
                        paths.push(path);
                      }
                      isSpace = !isSpace;
                      len = 0;
                      path = [];
                      loop = false;
                    }
                  }
                }
                if (i === cliped.paths.length - 1) {
                  paths.push(path);
                }
              }
            }
          }
          return paths;
        }

        // 更新线
        function updateLine() {
          lineLayer.removeAll();
          linesPath.forEach((item) => {
            let paths = [];
            let p1; // 用来计算箭头方向的点
            let p2; // 用来计算箭头方向的点
            if (item.lineStyle === 'straight') {
              let fullLine = createLineByPoints(item.points);
              let cliped = geometryEngine.clip(fullLine, view.extent); // 裁剪后的
              if (cliped && cliped.paths.length && cliped.paths[0].length) {
                for (let i = 0; i < cliped.paths.length; i++) {
                  let arr = [];
                  for (let j = 1; j < cliped.paths[i].length; j++) {
                    let dottedPaths = getSegmentDottedPaths(
                      cliped.paths[i][j - 1],
                      cliped.paths[i][j]
                    );
                    arr.push(...dottedPaths);
                  }
                  paths.push(...arr);
                }
                let number = item.points.length; // 点的数量
                p1 = [item.points[number - 2].x, item.points[number - 2].y];
                p2 = [item.points[number - 1].x, item.points[number - 1].y];
              }
            } else if (item.lineStyle === 'curve') {
              // 曲线
              let points = item.points.map((point) => [point.x, point.y]); // 将x,y坐标转换为数组模式
              paths = getCurvePaths(points);
              if (paths.length > 0) {
                let pathsLength = paths.length;
                let pathLength = paths[pathsLength - 1].length;
                let endPoint = paths[pathsLength - 1][pathLength - 1];
                // 判断最后一个点坐标是否是点击的最后一个坐标
                if (
                  endPoint[0] === points[points.length - 1][0] &&
                  endPoint[1] === points[points.length - 1][1]
                ) {
                  p1 = paths[pathsLength - 1][pathLength - 2];
                  p2 = paths[pathsLength - 1][pathLength - 1];
                }
              }
            }
            // 获取箭头的paths
            if (paths.length > 0) {
              if (p1 && p2) {
                let arrowPaths = getArrowPaths(p1, p2);
                paths = paths.concat(arrowPaths);
              }
              let line = new Polyline({
                paths: paths,
                spatialReference: view.spatialReference,
              });
              let lineGraphic = new Graphic({
                geometry: line,
                symbol: lineSymbol,
              });
              lineLayer.add(lineGraphic);
            }
          });
        }

        // 通过点列表生成线
        function createLineByPoints(points) {
          let paths = points.map((point) => [point.x, point.y]);
          let line = new Polyline({
            paths: [paths],
            spatialReference: view.spatialReference,
          });
          return line;
        }

        // 获取线段的虚线paths
        function getSegmentDottedPaths(p1, p2) {
          let resolution = view.resolution;
          let distance = 20 * resolution;
          let alpha = 0; // 角度

          if (p2[0] - p1[0] !== 0) {
            alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));
            if (p2[0] < p1[0]) {
              alpha += Math.PI;
            }
          }

          // 两点之间的长度
          let length = Math.sqrt(
            Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2)
          );
          let segmentLength = Math.floor(length / distance); // 线段数量
          let paths = [];
          for (let i = 0; i <= segmentLength; i++) {
            if (i % 2 === 0) {
              let startX = p1[0] + distance * i * Math.cos(alpha);
              let startY = p1[1] + distance * i * Math.sin(alpha);
              let endX = p1[0] + distance * (i + 1) * Math.cos(alpha);
              let endY = p1[1] + distance * (i + 1) * Math.sin(alpha);
              if (i === segmentLength) {
                endX = p2[0];
                endY = p2[1];
              }
              paths.push([
                [startX, startY],
                [endX, endY],
              ]);
            } else if (i === segmentLength) {
              paths[paths.length - 1].push([p2[0], p2[1]]);
            }
          }
          return paths;
        }

        // 获取箭头paths
        function getArrowPaths(p1, p2) {
          let resolution = view.resolution; // 分辨率
          let distance = 20 * resolution; // 箭头长度
          // 最后一段线段长度
          let length = Math.sqrt(
            Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2)
          );
          let ratio = distance / length; // 比例
          let deltaX = (p2[0] - p1[0]) * ratio;
          let deltaY = (p2[1] - p1[1]) * ratio;
          let p0 = [p2[0] - deltaX, p2[1] - deltaY];
          let line = new Polyline({
            paths: [
              [
                [p0[0], p0[1]],
                [p2[0], p2[1]],
              ],
            ],
            spatialReference: view.spatialReference,
          });
          let point2 = new Point({
            x: p2[0],
            y: p2[1],
            spatialReference: view.spatialReference,
          });
          let line1 = geometryEngine.rotate(line, 30, point2);
          let line2 = geometryEngine.rotate(line, -30, point2);
          let paths = [];
          paths.push(...line.paths);
          paths.push(...line1.paths);
          paths.push(...line2.paths);
          return paths;
        }
      });

      function getBezierPoints(num, p1, p2, p3, p4) {
        const points = [];
        for (let i = 0; i < num; i++) {
          points.push(threeBezier(i / num, p1, p2, p3, p4));
        }
        points.push([...p4]);
        return points;
      }

      /**
       * @desc 三阶贝塞尔
       * @param {number} t 当前百分比
       * @param {Array} p1 起点坐标
       * @param {Array} cp1 控制点1
       * @param {Array} cp2 控制点2
       * @param {Array} p2 终点坐标
       * @return 返回点坐标
       */
      function threeBezier(t, p1, cp1, cp2, p2) {
        const [x1, y1] = p1;
        const [x2, y2] = p2;
        const [cx1, cy1] = cp1;
        const [cx2, cy2] = cp2;
        let x =
          x1 * (1 - t) * (1 - t) * (1 - t) +
          3 * cx1 * t * (1 - t) * (1 - t) +
          3 * cx2 * t * t * (1 - t) +
          x2 * t * t * t;
        let y =
          y1 * (1 - t) * (1 - t) * (1 - t) +
          3 * cy1 * t * (1 - t) * (1 - t) +
          3 * cy2 * t * t * (1 - t) +
          y2 * t * t * t;
        return [x, y];
      }

      function getDis(dis1, dis2) {
        let v =
          (dis1[0] - dis2[0]) * (dis1[0] - dis2[0]) +
          (dis1[1] - dis2[1]) * (dis1[1] - dis2[1]);
        return Math.sqrt(v);
      }

      // 计算贝塞尔曲线的控制点
      function getBezierControlPoints(pointList, smoothValue = 1) {
        let ctrlList = [pointList[0]];
        for (let i = 0; i < pointList.length; i++) {
          if (i === 0 || i === pointList.length - 1) {
            continue;
          }
          let [a_x, a_y] = pointList[i - 1]; // 第1个顶点
          let [b_x, b_y] = pointList[i]; // 第2个顶点
          let [c_x, c_y] = pointList[i + 1]; // 第3个顶点
          let ab_x = (a_x + b_x) / 2.0;
          let ab_y = (a_y + b_y) / 2.0;
          let bc_x = (c_x + b_x) / 2.0;
          let bc_y = (c_y + b_y) / 2.0;
          let len1 = getDis(pointList[i - 1], pointList[i]);
          let len2 = getDis(pointList[i + 1], pointList[i]);
          let k1 = len1 / (len1 + len2);
          let d_x = ab_x + (bc_x - ab_x) * k1;
          let d_y = ab_y + (bc_y - ab_y) * k1;
          let ctrl0_x = b_x + (ab_x - d_x) * smoothValue;
          let ctrl0_y = b_y + (ab_y - d_y) * smoothValue;
          let ctrl1_x = b_x + (bc_x - d_x) * smoothValue;
          let ctrl1_y = b_y + (bc_y - d_y) * smoothValue;
          ctrlList.push([ctrl0_x, ctrl0_y]);
          ctrlList.push([ctrl1_x, ctrl1_y]);
        }
        ctrlList.push(pointList[pointList.length - 1]);
        return ctrlList;
      }
    </script>
  </head>
  <body>
    <div id="viewDiv"></div>
    <form id="form" style="position: absolute; top: 50px; right: 50px">
      <label>
        <input type="radio" value="straight" name="lineStyle" checked />
        <span>直线</span>
      </label>
      <label>
        <input type="radio" value="curve" name="lineStyle" />
        <span>曲线</span>
      </label>
    </form>
  </body>
</html>
