<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <title>ArcGIS JS API实现风场效果</title>
    <style>
      html,
      body,
      #viewDiv {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
      }
    </style>

    <link
      rel="stylesheet"
      href="https://js.arcgis.com/4.19/esri/css/main.css"
    />
    <script src="https://js.arcgis.com/4.19/"></script>

    <script type="module">
      import Particle from './Particle.js';
      import Grid from './Grid.js';

      require([
        'esri/Map',
        'esri/Basemap',
        'esri/Graphic',
        'esri/layers/TileLayer',
        'esri/views/MapView',
        'esri/layers/GraphicsLayer',
        'esri/layers/Layer',
        'esri/views/2d/layers/BaseLayerView2D',
      ], function (
        Map,
        Basemap,
        Graphic,
        TileLayer,
        MapView,
        GraphicsLayer,
        Layer,
        BaseLayerView2D
      ) {
        let JSONData;
        fetch('./uv0.json', { method: 'get' })
          .then((res) => res.json())
          .then((data) => {
            JSONData = data;

            let customLayer = new CustomLayer({
              data: JSONData,
            });
            view.map.add(customLayer);
          });

        const CustomLayerView2D = BaseLayerView2D.createSubclass({
          attach() {
            console.log(this);
            this.offscreenCanvas = document.createElement('canvas'); // 离屏渲染
            this.offscreenCanvas.width = this.view.width;
            this.offscreenCanvas.height = this.view.height;
            this.canvasCtx = this.offscreenCanvas.getContext('2d');

            // 创建棋盘
            let grid = new Grid(this.layer.data, 3000, this.view);
            this.grid = grid;

            let self = this;

            function animate() {
              self.requestRender();
              requestAnimationFrame(animate);
            }
            requestAnimationFrame(animate);
            // (function frame() {
            //   self.animateFrame = requestAnimationFrame(frame);
            //   self.requestRender();
            // })();
          },
          render(renderParameters) {
            var { state, context } = renderParameters;
            var pixelRatio = state.pixelRatio;
            var {
              size: [width, height],
            } = state;

            // apply rotation for everything that will be applied to the canvas
            if (state.rotation !== 0) {
              context.translate(
                width * pixelRatio * 0.5,
                height * pixelRatio * 0.5
              );
              context.rotate((state.rotation * Math.PI) / 180);
              context.translate(
                -width * pixelRatio * 0.5,
                -height * pixelRatio * 0.5
              );
            }

            // 将离屏渲染的图像渲染出来
            context.drawImage(this.offscreenCanvas, 0, 0);

            // 更新状态
            this.updateStatus(renderParameters);
          },
          // 更新状态
          updateStatus(renderParameters) {
            let { state } = renderParameters;
            let {
              size: [width, height],
            } = state;

            // 更新粒子数组
            // this.particles = this.particles.map((particle) => {
            //   particle.update(); // 调用粒子实例的更新方法
            //   if (particle.lifetime < 0) {
            //     // 如果粒子的生命周期小于0，则生成一个新的粒子
            //     let x = Math.floor(Math.random() * width); // 生成随机坐标x
            //     let y = Math.floor(Math.random() * height); // 生成随机坐标y
            //     return new Particle(x, y);
            //   } else {
            //     return particle;
            //   }
            // });

            this.grid.updateParticles();

            // 渲染离屏canvas
            this.offscreenCanvasRender();

            // 渲染
            // this.requestRender();
          },

          // offscreen canvas render
          offscreenCanvasRender() {
            this.canvasCtx.lineWidth = 2; // 设置线宽
            this.canvasCtx.globalCompositeOperation = 'destination-in'; // 设置模式为：目标图形和源图形重叠的部分会被保留（源图形），其余显示为透明
            this.canvasCtx.fillRect(0, 0, this.view.width, this.view.height); // 绘制矩形
            this.canvasCtx.globalCompositeOperation = 'lighter'; // 设置模式为: 源图像 + 目标图像。重叠部分的颜色会重新计算
            this.canvasCtx.globalAlpha = 0.8; // 设置画布上绘制图形的不透明度

            this.canvasCtx.beginPath(); // 开始一条新路径
            this.canvasCtx.strokeStyle = '#00ffff'; // 设置画笔路径的颜色
            // 绘制每个粒子产生的新路径
            this.grid.particles.forEach((particle) => {
              this.canvasCtx.moveTo(particle.x, particle.y); // 从粒子的旧坐标
              this.canvasCtx.lineTo(particle.nextX, particle.nextY); // 到粒子的新坐标
            });
            this.canvasCtx.stroke(); // 沿着路径绘制一条线
            this.canvasCtx.closePath(); // 关闭路径
          },
        });

        const CustomLayer = Layer.createSubclass({
          createLayerView(view) {
            if (view.type === '2d') {
              return new CustomLayerView2D({
                view: view,
                layer: this,
              });
            }
          },
        });

        const basemap = new Basemap({
          baseLayers: [
            new TileLayer({
              url: 'http://map.geoq.cn/arcgis/rest/services/ChinaOnlineStreetPurplishBlue/MapServer',
              title: 'Basemap',
            }),
          ],
        });

        const view = new MapView({
          container: 'viewDiv',
          map: new Map({
            basemap: basemap,
            layers: [],
          }),
        });
        view.goTo(
          {
            center: [105.48524370782414, 34.864064603585476],
            zoom: 4,
          },
          {
            duration: 1000,
          }
        );
        window.view = view;

        let graphics = [
          createGraphic(120, 30), //
          createGraphic(110, 20),
          createGraphic(100, 40),
          createGraphic(120, 40),
          createGraphic(120, 50),
        ];

        let layer2 = new GraphicsLayer({
          graphics: graphics,
        });
        view.map.add(layer2);

        // 创建graphic
        function createGraphic(x, y) {
          return new Graphic({
            geometry: {
              type: 'point',
              spatialReference: {
                wkid: 3857,
              },
              longitude: x,
              latitude: y,
            },
            symbol: {
              type: 'simple-marker', // autocasts as new SimpleMarkerSymbol()
              style: 'square',
              color: 'blue',
              size: '8px', // pixels
              outline: {
                color: [255, 255, 0],
                width: 2, // points
              },
            },
          });
        }
      });
    </script>
  </head>
  <body>
    <div id="viewDiv"></div>
  </body>
</html>
